
#include "hal_data.h"
#include "xprintf_helper.h"
#include "xprintf.h"

#include "sccb_if.h"

#define NEED_XPRINTF_MESSAGE (1)

uint32_t g_flag;
i2c_master_event_t g_i2c_callback_event;

static const cam_reg_value_t ov5642_init_reg_tbl[] = {
    // PLL
    {0x31, 0x03, 0x93}, // Reset system
    {0x30, 0x08, 0x82}, // output enable(1)
    {0x30, 0x17, 0x7f}, // output enable(2)
    {0x30, 0x18, 0xfc}, // HV offset setting
    {0x38, 0x10, 0xc2}, // analog setting
    {0x36, 0x15, 0xf0}, // block init
    {0x30, 0x00, 0x00},
    {0x30, 0x01, 0x00},
    {0x30, 0x02, 0x00},
    {0x30, 0x03, 0x00},
    {0x30, 0x00, 0xf8},
    {0x30, 0x01, 0x48},
    {0x30, 0x02, 0x5c},
    {0x30, 0x03, 0x02}, // block clock enable
    {0x30, 0x04, 0x07},
    {0x30, 0x05, 0xb7},
    {0x30, 0x06, 0x43},
    {0x30, 0x07, 0x37}, // PLL(FPS)
    // 0x3011=0x08:15fps
    // 0x3011=0x10:30fps
    {0x30, 0x11, 0x08},
    {0x30, 0x10, 0x10}, // VFIFO
    {0x46, 0x0c, 0x22}, // unknown settings
    {0x38, 0x15, 0x04}, // array control
    {0x37, 0x0d, 0x06}, // analog settings
    {0x37, 0x0c, 0xa0},
    {0x36, 0x02, 0xfc},
    {0x36, 0x12, 0xff},
    {0x36, 0x34, 0xc0},
    {0x36, 0x13, 0x00},
    {0x36, 0x05, 0x7c}, // array control
    {0x36, 0x21, 0x09}, // analog settings
    {0x36, 0x22, 0x00},
    {0x36, 0x04, 0x40},
    {0x36, 0x03, 0xa7},
    {0x36, 0x03, 0x27}, // black color level
    {0x40, 0x00, 0x21},
    {0x40, 0x1d, 0x02}, // analog settings
    {0x36, 0x00, 0x54},
    {0x36, 0x05, 0x04},
    {0x36, 0x06, 0x3f}, // flicker
    {0x3c, 0x01, 0x80}, // ISP
    {0x50, 0x00, 0x4f}, // unknown
    {0x50, 0x20, 0x04}, // AWB
    {0x51, 0x81, 0x79},
    {0x51, 0x82, 0x00},
    {0x51, 0x85, 0x22},
    {0x51, 0x97, 0x01}, // ISP
    {0x50, 0x01, 0xff}, // UV adjust
    {0x55, 0x00, 0x0a},
    {0x55, 0x04, 0x00},
    {0x55, 0x05, 0x7f}, // ISP
    {0x50, 0x80, 0x08}, // MIPI
    {0x30, 0x0e, 0x18}, // unknown
    {0x46, 0x10, 0x00}, // DVP output
    {0x47, 0x1d, 0x05},
    {0x47, 0x08, 0x06}, // analog setting register
    {0x37, 0x10, 0x10},
    {0x36, 0x32, 0x41},
    {0x37, 0x02, 0x40},
    {0x36, 0x20, 0x37},
    {0x36, 0x31, 0x01}, // output setting
    {0x38, 0x08, 0x01},
    {0x38, 0x09, 0x00},
    {0x38, 0x0a, 0x01},
    {0x38, 0x0b, 0x00}, // 0xe0;

    // V-size:0x01e0 = 480, 0x0200 = 512, 0x0100 = 256
    {0x38, 0x0e, 0x07},
    {0x38, 0x0f, 0xd0}, // V-pixel:0x07d0 = 2000

    // select output format
    {0x50, 0x1f, 0x00}, // ISP Settings
    {0x50, 0x00, 0x4f}, // output format settings
    {0x51, 0x1e, 0x2a},
    {0x50, 0x02, 0xf8},
    {0x50, 0x1f, 0x01},
    {0x43, 0x00, 0x61}, // 0x61=RGB565, 0xF9=YUV422(=Y8,U4,V4)
    // AEC Settings
    {0x35, 0x03, 0x07}, // VTS Manual
    {0x35, 0x01, 0x73}, // shutter speed
    {0x35, 0x02, 0x80}, // shutter speed
    {0x35, 0x0b, 0x00}, // AGC Gain
    {0x35, 0x03, 0x07}, // VTS manual
    // unknown
    {0x38, 0x24, 0x11}, // AEC Settings
    {0x35, 0x01, 0x1e},
    {0x35, 0x02, 0x80}, // AGC Settings
    {0x35, 0x0b, 0x7f}, // output timing settings
    {0x38, 0x0c, 0x0c},
    {0x38, 0x0d, 0x80},
    {0x38, 0x0e, 0x03},
    {0x38, 0x0f, 0xe8}, // flicker-less settings
    {0x3a, 0x0d, 0x04}, // 60Hz
    {0x3a, 0x0e, 0x03}, // 50Hz
    // timing and mirror and flip settings
    // ov5642 default position (0 degrees)
    // 0x3818 = 0xC1,
    // 0x3621 = 0xC7,
    // or if you use ov5642 upside down (turn 180 degrees)
    // 0x3818 = 0xA1,
    // 0x3621 = 0xA7,
    {0x38, 0x18, 0xA1}, // analog settings register
    {0x37, 0x05, 0xdb},
    {0x37, 0x0a, 0x81},
    // array control
    {0x36, 0x21, 0xA7},
    // output timing
    {0x38, 0x01, 0x50}, // H-Start:80
    {0x38, 0x03, 0x08}, // V-Start:8
    // unknown
    {0x38, 0x27, 0x08}, // HV offset settings
    {0x38, 0x10, 0xc0}, // output timing
    {0x38, 0x04, 0x05},
    {0x38, 0x05, 0x00}, // Statistics Settings
    {0x56, 0x82, 0x05},
    {0x56, 0x83, 0x00}, // output timing
    {0x38, 0x06, 0x03},
    {0x38, 0x07, 0xc0}, // V-pixel:960
    // Statistics Settings
    {0x56, 0x86, 0x03},
    {0x56, 0x87, 0xc0}, // V-pixel:960
    // #102:AEC Settings
    {0x3a, 0x00, 0x78},
    {0x3a, 0x1a, 0x04},
    {0x3a, 0x13, 0x30},
    {0x3a, 0x18, 0x00},
    {0x3a, 0x19, 0x7c}, // #107: flicker-less settings
    {0x3a, 0x08, 0x12},
    {0x3a, 0x09, 0xc0},
    {0x3a, 0x0a, 0x0f},
    {0x3a, 0x0b, 0xa0}, // #111: block clock enable
    {0x30, 0x04, 0xff}, // #112: AEC Settings
    {0x35, 0x0c, 0x07},
    {0x35, 0x0d, 0xd0},
    {0x35, 0x00, 0x00},
    {0x35, 0x01, 0x00},
    {0x35, 0x02, 0x00}, // #117: AGC/AEC Settings
    {0x35, 0x0a, 0x00},
    {0x35, 0x0b, 0x00},
    {0x35, 0x03, 0x00}, // #120: De-Noise Settings
    {0x52, 0x8a, 0x02},
    {0x52, 0x8b, 0x04},
    {0x52, 0x8c, 0x08},
    {0x52, 0x8d, 0x08},
    {0x52, 0x8e, 0x08},
    {0x52, 0x8f, 0x10},
    {0x52, 0x90, 0x10},
    {0x52, 0x92, 0x00},
    {0x52, 0x93, 0x02},
    {0x52, 0x94, 0x00},
    {0x52, 0x95, 0x02},
    {0x52, 0x96, 0x00},
    {0x52, 0x97, 0x02},
    {0x52, 0x98, 0x00},
    {0x52, 0x99, 0x02},
    {0x52, 0x9a, 0x00},
    {0x52, 0x9b, 0x02},
    {0x52, 0x9c, 0x00},
    {0x52, 0x9d, 0x02},
    {0x52, 0x9e, 0x00},
    {0x52, 0x9f, 0x02}, // #141: AEC Settings
    {0x3a, 0x0f, 0x3c},
    {0x3a, 0x10, 0x30},
    {0x3a, 0x1b, 0x3c},
    {0x3a, 0x1e, 0x30},
    {0x3a, 0x11, 0x70},
    {0x3a, 0x1f, 0x10}, // #147: system settings
    {0x30, 0x30, 0x0b}, // #148: AEC Settings
    {0x3a, 0x02, 0x00},
    {0x3a, 0x03, 0x7d},
    {0x3a, 0x04, 0x00},
    {0x3a, 0x14, 0x00},
    {0x3a, 0x15, 0x7d},
    {0x3a, 0x16, 0x00},
    {0x3a, 0x00, 0x7c}, // #155: flicker-less settings
    {0x3a, 0x08, 0x09},
    {0x3a, 0x09, 0x60},
    {0x3a, 0x0a, 0x07},
    {0x3a, 0x0b, 0xd0},
    {0x3a, 0x0d, 0x08},
    {0x3a, 0x0e, 0x06}, // #161: AWB settings
    {0x51, 0x93, 0x70}, // #162: analog settings
    {0x36, 0x20, 0x57},
    {0x37, 0x03, 0x98},
    {0x37, 0x04, 0x1c}, // #165: unknown settings
    {0x58, 0x9b, 0x04},
    {0x58, 0x9a, 0xc5}, // #167: De-Noise Settings
    {0x52, 0x8a, 0x00},
    {0x52, 0x8b, 0x02},
    {0x52, 0x8c, 0x08},
    {0x52, 0x8d, 0x10},
    {0x52, 0x8e, 0x20},
    {0x52, 0x8f, 0x28},
    {0x52, 0x90, 0x30},
    {0x52, 0x92, 0x00},
    {0x52, 0x93, 0x00},
    {0x52, 0x94, 0x00},
    {0x52, 0x95, 0x02},
    {0x52, 0x96, 0x00},
    {0x52, 0x97, 0x08},
    {0x52, 0x98, 0x00},
    {0x52, 0x99, 0x10},
    {0x52, 0x9a, 0x00},
    {0x52, 0x9b, 0x20},
    {0x52, 0x9c, 0x00},
    {0x52, 0x9d, 0x28},
    {0x52, 0x9e, 0x00},
    {0x52, 0x9f, 0x30},
    {0x52, 0x82, 0x00}, // #189: CIP
    {0x53, 0x00, 0x00},
    {0x53, 0x01, 0x20},
    {0x53, 0x02, 0x00},
    {0x53, 0x03, 0x7c},
    {0x53, 0x0c, 0x00},
    {0x53, 0x0d, 0x0c},
    {0x53, 0x0e, 0x20},
    {0x53, 0x0f, 0x80},
    {0x53, 0x10, 0x20},
    {0x53, 0x11, 0x80},
    {0x53, 0x08, 0x20},
    {0x53, 0x09, 0x40},
    {0x53, 0x04, 0x00},
    {0x53, 0x05, 0x30},
    {0x53, 0x06, 0x00},
    {0x53, 0x07, 0x80},
    {0x53, 0x14, 0x08},
    {0x53, 0x15, 0x20},
    {0x53, 0x19, 0x30},
    {0x53, 0x16, 0x10},
    {0x53, 0x17, 0x08},
    {0x53, 0x18, 0x02}, // #211: Color Matrix Settings
    {0x53, 0x80, 0x01},
    {0x53, 0x81, 0x00},
    {0x53, 0x82, 0x00},
    {0x53, 0x83, 0x4e},
    {0x53, 0x84, 0x00},
    {0x53, 0x85, 0x0f},
    {0x53, 0x86, 0x00},
    {0x53, 0x87, 0x00},
    {0x53, 0x88, 0x01},
    {0x53, 0x89, 0x15},
    {0x53, 0x8a, 0x00},
    {0x53, 0x8b, 0x31},
    {0x53, 0x8c, 0x00},
    {0x53, 0x8d, 0x00},
    {0x53, 0x8e, 0x00},
    {0x53, 0x8f, 0x0f},
    {0x53, 0x90, 0x00},
    {0x53, 0x91, 0xab},
    {0x53, 0x92, 0x00},
    {0x53, 0x93, 0xa2},
    {0x53, 0x94, 0x08}, // #232: Gamma Setings
    {0x54, 0x80, 0x14},
    {0x54, 0x81, 0x21},
    {0x54, 0x82, 0x36},
    {0x54, 0x83, 0x57},
    {0x54, 0x84, 0x65},
    {0x54, 0x85, 0x71},
    {0x54, 0x86, 0x7d},
    {0x54, 0x87, 0x87},
    {0x54, 0x88, 0x91},
    {0x54, 0x89, 0x9a},
    {0x54, 0x8a, 0xaa},
    {0x54, 0x8b, 0xb8},
    {0x54, 0x8c, 0xcd},
    {0x54, 0x8d, 0xdd},
    {0x54, 0x8e, 0xea},
    {0x54, 0x8f, 0x10},
    {0x54, 0x90, 0x05},
    {0x54, 0x91, 0x00},
    {0x54, 0x92, 0x04},
    {0x54, 0x93, 0x20},
    {0x54, 0x94, 0x03},
    {0x54, 0x95, 0x60},
    {0x54, 0x96, 0x02},
    {0x54, 0x97, 0xb8},
    {0x54, 0x98, 0x02},
    {0x54, 0x99, 0x86},
    {0x54, 0x9a, 0x02},
    {0x54, 0x9b, 0x5b},
    {0x54, 0x9c, 0x02},
    {0x54, 0x9d, 0x3b},
    {0x54, 0x9e, 0x02},
    {0x54, 0x9f, 0x1c},
    {0x54, 0xa0, 0x02},
    {0x54, 0xa1, 0x04},
    {0x54, 0xa2, 0x01},
    {0x54, 0xa3, 0xed},
    {0x54, 0xa4, 0x01},
    {0x54, 0xa5, 0xc5},
    {0x54, 0xa6, 0x01},
    {0x54, 0xa7, 0xa5},
    {0x54, 0xa8, 0x01},
    {0x54, 0xa9, 0x6c},
    {0x54, 0xaa, 0x01},
    {0x54, 0xab, 0x41},
    {0x54, 0xac, 0x01},
    {0x54, 0xad, 0x20},
    {0x54, 0xae, 0x00},
    {0x54, 0xaf, 0x16}, // #280: AWB Settings
    {0x34, 0x06, 0x00},
    {0x51, 0x92, 0x04},
    {0x51, 0x91, 0xf8},
    {0x51, 0x93, 0xf0}, // R
    {0x51, 0x94, 0x40}, // G
    {0x51, 0x95, 0xf0}, // B
    {0x51, 0x8d, 0x3d},
    {0x51, 0x8f, 0x54},
    {0x51, 0x8e, 0x3d},
    {0x51, 0x90, 0x54},
    {0x51, 0x8b, 0xc0},
    {0x51, 0x8c, 0xbd},
    {0x51, 0x87, 0x18},
    {0x51, 0x88, 0x18},
    {0x51, 0x89, 0x6e},
    {0x51, 0x8a, 0x68},
    {0x51, 0x86, 0x1c},
    {0x51, 0x81, 0x50}, // #298: AWB Settings
    {0x51, 0x84, 0x25},
    {0x51, 0x82, 0x11},
    {0x51, 0x83, 0x14},
    {0x51, 0x84, 0x25},
    {0x51, 0x85, 0x24}, // ISP Settings
    {0x50, 0x25, 0x82}, // #304: AEC Settings
    {0x3a, 0x0f, 0x7e},
    {0x3a, 0x10, 0x72},
    {0x3a, 0x1b, 0x80},
    {0x3a, 0x1e, 0x70},
    {0x3a, 0x11, 0xd0},
    {0x3a, 0x1f, 0x40}, // #310: Digital effect
    {0x55, 0x83, 0x40},
    {0x55, 0x84, 0x40},
    {0x55, 0x80, 0x02}, // #313: Analog settings register
    {0x36, 0x33, 0x07},
    {0x37, 0x02, 0x10},
    {0x37, 0x03, 0xb2},
    {0x37, 0x04, 0x18},
    {0x37, 0x0b, 0x40}, // array control
    {0x37, 0x0d, 0x02}, // #319: analog settings register
    {0x36, 0x20, 0x52},
#if 1 // pclk=6MHz
    {0x30, 0x11, 0x08},
    {0x30, 0x12, 0x00},
    {0x30, 0x10, 0x70},
    {0x46, 0x0c, 0x22},
    {0x38, 0x0c, 0x0c},
    {0x38, 0x0d, 0x80},
    {0x3a, 0x00, 0x78},
    {0x3a, 0x08, 0x09},
    {0x3a, 0x09, 0x60},
    {0x3a, 0x0a, 0x07},
    {0x3a, 0x0b, 0xd0},
    {0x3a, 0x0d, 0x08},
    {0x3a, 0x0e, 0x06},
#endif
    // VSYNC Active-Low & Gate PCLK under VSYNC & HREF
    {0x47, 0x40, 0x2d},
    {0xFF, 0xFF, 0xFF}, // END MARKER
};

// Write n byte to the specified register
int32_t reg_write(uint32_t addr, // Camera's hw address
                  uint8_t *buf,
                  const uint8_t nbytes)
{
    uint32_t timeout_ms = 300;
    fsp_err_t err;
    int32_t num_bytes_read = 0;
    uint8_t msg[nbytes];

    // Check to make sure caller is sending 1 or more bytes
    if (nbytes < 1)
    {
        return 0;
    }

    // Append register address to front of data packet
    for (int32_t i = 0; i < nbytes; i++)
    {
        msg[i] = buf[i];
    }

    g_flag = 0;

    // Send data to I2C slave
    g_i2c_callback_event = I2C_MASTER_EVENT_ABORTED;
    err = R_IIC_MASTER_Write(&g_i2c_master1_ctrl, msg, nbytes, false);
    assert(FSP_SUCCESS == err);

    /* Since there is nothing else to do, block until Callback triggers*/
    while ((I2C_MASTER_EVENT_TX_COMPLETE != g_i2c_callback_event) && timeout_ms)
    {
        R_BSP_SoftwareDelay(1U, BSP_DELAY_UNITS_MILLISECONDS);
        timeout_ms--;
        ;
    }
    if (I2C_MASTER_EVENT_ABORTED == g_i2c_callback_event)
    {
        __BKPT(0);
    }

    xprintf("g_flag=%d\n", g_flag);
    g_flag = 0;
    num_bytes_read = nbytes;
    return num_bytes_read;
}

void g_i2c_callback(i2c_master_callback_args_t *p_args)
{
    g_i2c_callback_event = p_args->event;

    switch (g_i2c_callback_event)
    {
    case I2C_MASTER_EVENT_ABORTED:
        g_flag = 1;
        break;
    case I2C_MASTER_EVENT_RX_COMPLETE:
        g_flag = 2;
        break;
    case I2C_MASTER_EVENT_TX_COMPLETE:
        g_flag = 3;
        break;
    case I2C_MASTER_EVENT_START:
        g_flag = 4;
        break;
    case I2C_MASTER_EVENT_BYTE_ACK:
        g_flag = 5;
        break;
    default:
        g_flag = 0;
        break;
    }
}

void sccb_init(void)
{
    uint8_t sccb_dat[3];
    const cam_reg_value_t *reg_tbl = ov5642_init_reg_tbl;
    uint8_t CAM_ADDR = 0x00;
    fsp_err_t err;
    /////
    // init I2C HW
    err = R_IIC_MASTER_Open(&g_i2c_master1_ctrl, &g_i2c_master1_cfg);
    // Handle any errors. This function should be defined by the user.
    assert(FSP_SUCCESS == err);

    /////

    CAM_ADDR = (0x78 >> 1U);
    uint16_t i = 0;
    while (1)
    {
        sccb_dat[0] = reg_tbl[i].reg_high;
        sccb_dat[1] = reg_tbl[i].reg_low;
        sccb_dat[2] = reg_tbl[i].val;

        if (reg_tbl[i].reg_high == 0xFF &&
            reg_tbl[i].reg_low == 0xFF &&
            reg_tbl[i].val == 0xFF)
        {
            // 終了マーカーに達したら抜ける
            xprintf("Camera init end\n");
            break;
        }
        reg_write(CAM_ADDR, sccb_dat, 3);
        i++;
    }
}
